# ============================================================================
# Auto-update script for Windows
# Generated by nebulder - https://github.com/erykjj/nebulder
# MIT License: Copyright (c) 2026 Eryk J.
# ============================================================================

$ScriptDir = $PSScriptRoot
if ([string]::IsNullOrEmpty($ScriptDir)) {
    $ScriptDir = Get-Location
}

$LocalVersionFile = Join-Path $ScriptDir "version"
$LocalNodeFile = Join-Path $ScriptDir "node"
$BackupDir = Join-Path $ScriptDir "Backup"
$DownloadDir = Join-Path $ScriptDir "Download"
$ConfigFile = Join-Path $ScriptDir "update.conf"
$LogFile = Join-Path $ScriptDir "update.log"
$StatusFile = Join-Path $ScriptDir "update-status.json"
$NebulaBinary = Join-Path $ScriptDir "nebula.exe"

$ErrorActionPreference = "Stop"

$MaxLogSize = 1MB
if (Test-Path $LogFile) {
    $log = Get-Item $LogFile
    if ($log.Length -gt $MaxLogSize) {
        $oldLog = Join-Path $ScriptDir "update.log.old"
        Rename-Item -Path $LogFile -NewName $oldLog -Force
        Write-Log "INFO: Rotated log file"
    }
}

function Write-Log {
    param([string]$Message, [string]$Level = "INFO")
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntry = "[$timestamp] [$Level] $Message"
    Add-Content -Path $LogFile -Value $logEntry -ErrorAction SilentlyContinue
    switch ($Level) {
        "SUCCESS" { Write-Host $logEntry -ForegroundColor Green }
        "WARNING" { Write-Host $logEntry -ForegroundColor Yellow }
        "ERROR"   { Write-Host $logEntry -ForegroundColor Red }
        default   { Write-Host $logEntry }
    }
}

function Read-Config {
    if (-not (Test-Path $ConfigFile)) {
        Write-Log "Configuration file not found: $ConfigFile" -Level "ERROR"
        throw "Missing configuration file"
    }

    $config = @{}
    Get-Content $ConfigFile | ForEach-Object {
        if ($_ -match '^\s*([^=]+)\s*=\s*(.+)\s*$') {
            $key = $matches[1].Trim()
            $value = $matches[2].Trim('"'' ')
            $config[$key] = $value
        }
    }

    $required = @("UPDATE_SERVER", "AUTH_USER", "AUTH_PASS")
    foreach ($key in $required) {
        if (-not $config.ContainsKey($key) -or [string]::IsNullOrEmpty($config[$key])) {
            Write-Log "Missing required configuration: $key" -Level "ERROR"
            throw "Missing required configuration: $key"
        }
    }

    return $config
}

function Get-LocalVersion {
    if (Test-Path $LocalVersionFile) {
        return (Get-Content $LocalVersionFile -Raw).Trim()
    } else {
        return "0.0.0"
    }
}

function Get-NodeName {
    if (Test-Path $LocalNodeFile) {
        return (Get-Content $LocalNodeFile -Raw).Trim()
    } else {
        return $env:COMPUTERNAME
    }
}

function Get-RemoteVersion {
    param([string]$Server, [string]$User, [string]$Pass)

    $versionUrl = "$Server/version.txt"

    try {
        $credential = [System.Convert]::ToBase64String(
            [System.Text.Encoding]::ASCII.GetBytes("${User}:${Pass}")
        )

        $headers = @{ "Authorization" = "Basic $credential" }

        $response = Invoke-WebRequest -Uri $versionUrl -Headers $headers -TimeoutSec 10 -ErrorAction Stop -UseBasicParsing
        

        if ($response.StatusCode -eq 404) {
            return $null
        }
        elseif ($response.StatusCode -ne 200) {
            Write-Log "HTTP error $($response.StatusCode) fetching remote version" -Level "ERROR"
            return $null
        }

        $remoteVersion = $response.Content.Trim()

        if ([string]::IsNullOrEmpty($remoteVersion)) {
            Write-Log "Empty version.txt on server" -Level "INFO"
            return $null
        }

        Write-Log "Remote version: $remoteVersion" -Level "INFO"
        return $remoteVersion
    }
    catch [System.Net.WebException] {
        return $null
    }
    catch {
        return $null
    }
}

function Get-NebulaVersion {
    if (Test-Path $NebulaBinary) {
        try {
            $output = & $NebulaBinary --version 2>&1
            if ($LASTEXITCODE -eq 0) {
                $match = [regex]::Match($output, 'Version:\s*([0-9\.]+)')
                if ($match.Success) {
                    return $match.Groups[1].Value
                }
            }
        }
        catch {}
    }
    return "unknown"
}

function Check-Update {
    param(
        [string]$LocalVersion,
        [string]$RemoteVersion
    )

    if ([string]::IsNullOrEmpty($RemoteVersion)) {
        Write-Log "Remote version unavailable (server may have no updates)" -Level "INFO"
        return $false, "NO_VERSION_FILE"
    }

    if ($LocalVersion -eq $RemoteVersion) {
        Write-Log "No update needed (already at version: $LocalVersion)" -Level "INFO"
        return $false, "NO_UPDATE"
    }

    Write-Log "Update available: $LocalVersion -> $RemoteVersion" -Level "INFO"
    return $true, "UPDATE_AVAILABLE"
}

function Create-Backup {
    Write-Log "Creating backup"

    if (Test-Path $BackupDir) {
        Remove-Item -Path $BackupDir -Recurse -Force -ErrorAction SilentlyContinue
    }

    try {
        New-Item -ItemType Directory -Path $BackupDir -Force | Out-Null

        if (Test-Path $NebulaBinary) {
            Copy-Item -Path $NebulaBinary -Destination $BackupDir -Force -ErrorAction Stop
        }

        Get-ChildItem -Path $ScriptDir -File | Where-Object {
            $_.Name -notmatch '\.log$|update-status\.json$'
        } | ForEach-Object {
            Copy-Item -Path $_.FullName -Destination $BackupDir -Force -ErrorAction SilentlyContinue
        }

        return $true
    }
    catch {
        Write-Log "Failed to create backup" -Level "ERROR"
        return $false
    }
}

function Download-Package {
    param([string]$Server, [string]$User, [string]$Pass, [string]$RemoteVersion, [string]$NodeName)

    $packageName = "${NodeName}_${RemoteVersion}.zip"
    $packageUrl = "$Server/$packageName"
    Write-Log "Downloading package: $packageName"

    if (Test-Path $DownloadDir) {
        Remove-Item -Path $DownloadDir -Recurse -Force -ErrorAction SilentlyContinue
    }

    try {
        New-Item -ItemType Directory -Path $DownloadDir -Force | Out-Null

        $credential = [System.Convert]::ToBase64String(
            [System.Text.Encoding]::ASCII.GetBytes("${User}:${Pass}")
        )

        $headers = @{ "Authorization" = "Basic $credential" }
        $zipPath = Join-Path $DownloadDir $packageName

        Invoke-WebRequest -Uri $packageUrl -Headers $headers -OutFile $zipPath -TimeoutSec 30 -ErrorAction Stop -UseBasicParsing

        Expand-Archive -Path $zipPath -DestinationPath $DownloadDir -Force -ErrorAction Stop
        Remove-Item -Path $zipPath -Force -ErrorAction SilentlyContinue

        return $DownloadDir
    }
    catch [System.Net.WebException] {
        Write-Log "Network error downloading package" -Level "ERROR"
        return $null
    }
    catch {
        Write-Log "Error downloading package" -Level "ERROR"
        return $null
    }
}

function Apply-Update {
    param([string]$PackageDir)

    $deployScript = Join-Path $PackageDir "deploy.ps1"

    if (-not (Test-Path $deployScript)) {
        Write-Log "ERROR: deploy.ps1 not found in package" -Level "ERROR"
        return $false
    }

    try {
        Write-Log "Running deployment script..." -Level "INFO"

        $deployOutput = & powershell.exe -ExecutionPolicy Bypass -File "$deployScript" 2>&1

        if ($deployOutput) {
            foreach ($line in $deployOutput) {
                Write-Log "  $line" -Level "INFO"
            }
        }

        if ($LASTEXITCODE -eq 0) {
            Write-Log "Deployment script completed successfully" -Level "SUCCESS"
            return $true
        } else {
            Write-Log "Deployment script failed with exit code: $LASTEXITCODE" -Level "ERROR"
            return $false
        }
    }
    catch {
        Write-Log "Failed to run deployment script: $_" -Level "ERROR"
        return $false
    }
}

function Verify-Update {
    param([string]$ExpectedVersion)

    if (-not (Test-Path $LocalVersionFile)) {
        Write-Log "Version file not found after update" -Level "ERROR"
        return $false
    }

    $newLocalVersion = (Get-Content $LocalVersionFile -Raw).Trim()

    if ($newLocalVersion -ne $ExpectedVersion) {
        Write-Log "Version mismatch after update" -Level "ERROR"
        return $false
    }

    $nebulaVersion = Get-NebulaVersion
    Write-Log "Nebula binary version: $nebulaVersion"

    try {
        $service = Get-Service -Name "Nebula" -ErrorAction SilentlyContinue
        if ($service -and $service.Status -eq "Running") {
            Write-Log "Nebula service is running" -Level "SUCCESS"
        }
    }
    catch {}

    return $true
}

function Restore-Backup {
    Write-Log "Restoring from backup" -Level "WARNING"

    if (-not (Test-Path $BackupDir)) {
        Write-Log "Backup directory not found" -Level "ERROR"
        return $false
    }

    try {
        if (Test-Path $NebulaBinary) {
            Start-Process -FilePath $NebulaBinary -ArgumentList "-service stop" -NoNewWindow -Wait -ErrorAction SilentlyContinue | Out-Null
            Start-Sleep -Seconds 2
        }

        Get-ChildItem -Path $BackupDir -File | ForEach-Object {
            $destination = Join-Path $ScriptDir $_.Name
            Copy-Item -Path $_.FullName -Destination $destination -Force -ErrorAction SilentlyContinue
        }

        Write-Log "Files restored from backup"

        if (Test-Path $NebulaBinary) {
            Start-Process -FilePath $NebulaBinary -ArgumentList "-service start" -NoNewWindow -Wait -ErrorAction SilentlyContinue | Out-Null
        }

        return $true
    }
    catch {
        Write-Log "Failed to restore backup" -Level "ERROR"
        return $false
    }
}

function Report-Result {
    param(
        [int]$ResultCode,
        [string]$OldVersion,
        [string]$NewVersion,
        [string]$Message = ""
    )

    $nodeName = Get-NodeName
    $nebulaVersion = Get-NebulaVersion

    switch ($ResultCode) {
        0 { $resultText = "updated" }
        1 { $resultText = "no_update" }
        2 { $resultText = "error" }
        default { $resultText = "unknown" }
    }

    if ($ResultCode -eq 0 -or $ResultCode -eq 2) {

        $status = @{
            node = $nodeName
            result = $resultText
            previous = $OldVersion
            current = $NewVersion
            nebula = $nebulaVersion
            timestamp = Get-Date -Format "yyyy-MM-ddTHH:mm:ss"
        }

        try {
            $statusJson = $status | ConvertTo-Json
            Set-Content -Path $StatusFile -Value $statusJson -ErrorAction SilentlyContinue
        }
        catch {
            Write-Log "WARNING: Could not write status file" -Level "WARNING"
        }

        if ($config.ContainsKey("NTFY_CHANNEL") -and -not [string]::IsNullOrEmpty($config.NTFY_CHANNEL)) {
            try {
                $channel = $config.NTFY_CHANNEL.Trim()
                if (-not [string]::IsNullOrEmpty($channel)) {
                    $ntfyUrl = "https://ntfy.sh/$channel"
                    $title = "$nodeName @ @@tun_device@@"

                    switch ($ResultCode) {
                        0 { # SUCCESS
                            $tags = "white_check_mark"
                            $priority = 3
                            $body = "Updated from $OldVersion --> $NewVersion`nNebula version: $nebulaVersion"
                        }
                        2 { # ERROR
                            $tags = "warning"
                            $priority = 4
                            $body = "ERROR on update from $OldVersion --> $NewVersion`nNebula version: $nebulaVersion"
                            if (-not [string]::IsNullOrEmpty($Message)) {
                                $body += "`nError: $Message"
                            }
                        }
                    }

                    Invoke-RestMethod -Uri $ntfyUrl -Method Post -Body $body `
                        -Headers @{ Title = $title; Tags = $tags; Priority = $priority } `
                        -ErrorAction SilentlyContinue | Out-Null
                }
            }
            catch {
                Write-Log "WARNING: Failed to send ntfy.sh notification" -Level "WARNING"
            }
        }
    }

    return $ResultCode
}

function Cleanup-Temp {
    if (Test-Path $BackupDir) {
        Remove-Item -Path $BackupDir -Recurse -Force -ErrorAction SilentlyContinue
    }

    if (Test-Path $DownloadDir) {
        Remove-Item -Path $DownloadDir -Recurse -Force -ErrorAction SilentlyContinue
    }
}

try {
    Write-Log "Nebula Auto-Update for Windows"

    $config = Read-Config
    $oldVersion = Get-LocalVersion
    $nodeName = Get-NodeName

    $remoteVersion = Get-RemoteVersion -Server $config.UPDATE_SERVER -User $config.AUTH_USER -Pass $config.AUTH_PASS
    $updateNeeded, $updateStatus = Check-Update -LocalVersion $oldVersion -RemoteVersion $remoteVersion

    if (-not $updateNeeded) {
        if ($updateStatus -eq "NO_VERSION_FILE") {
            exit 1
        } elseif ($updateStatus -eq "ERROR_FETCH") {
            Write-Log "Update check failed" -Level "ERROR"
            Report-Result -ResultCode 2 -OldVersion $oldVersion -NewVersion $remoteVersion -Message "Failed to fetch remote version"
            exit 2
        } else {
            Report-Result -ResultCode 1 -OldVersion $oldVersion -NewVersion $oldVersion
            exit 1
        }
    }

    $packageDir = Download-Package -Server $config.UPDATE_SERVER -User $config.AUTH_USER -Pass $config.AUTH_PASS -RemoteVersion $remoteVersion -NodeName $nodeName
    if (-not $packageDir) {
        Write-Log "Download failed, no backup needed" -Level "ERROR"
        throw "Failed to download update package"
    }

    if (-not (Create-Backup)) {
        if (Test-Path $DownloadDir) {
            Remove-Item -Path $DownloadDir -Recurse -Force -ErrorAction SilentlyContinue
        }
        throw "Failed to create backup, aborting update"
    }

    if (-not (Apply-Update -PackageDir $packageDir)) {
        Write-Log "Update application failed, restoring backup..." -Level "ERROR"
        Restore-Backup
        throw "Failed to apply update"
    }

    if (-not (Verify-Update -ExpectedVersion $remoteVersion)) {
        Write-Log "Update verification failed, restoring backup..." -Level "ERROR"
        Restore-Backup
        throw "Update verification failed"
    }

    Cleanup-Temp

    Write-Log "Update completed: $oldVersion -> $remoteVersion" -Level "SUCCESS"

    Report-Result -ResultCode 0 -OldVersion $oldVersion -NewVersion $remoteVersion
    exit 0
}
catch {
    Write-Log "UPDATE FAILED: $_" -Level "ERROR"

    try {
        Report-Result -ResultCode 2 -OldVersion $oldVersion -NewVersion $remoteVersion -Message $_.Exception.Message
    }
    catch {}

    exit 2
}