# ============================================================================
# Auto-update script for Windows
# Generated by nebulder - https://github.com/erykjj/nebulder
# MIT License: Copyright (c) 2026 Eryk J.
# ============================================================================

# ----------------------------------------------------------------------------
# Configuration and Paths
# ----------------------------------------------------------------------------

$ScriptDir = $PSScriptRoot
if ([string]::IsNullOrEmpty($ScriptDir)) {
    $ScriptDir = Get-Location
}

$LocalVersionFile = Join-Path $ScriptDir "version"
$LocalNodeFile = Join-Path $ScriptDir "node"
$BackupDir = Join-Path $ScriptDir "Backup"
$DownloadDir = Join-Path $ScriptDir "Download"
$ConfigFile = Join-Path $ScriptDir "update.conf"
$LogFile = Join-Path $ScriptDir "update.log"
$StatusFile = Join-Path $ScriptDir "update-status.json"
$NebulaBinary = Join-Path $ScriptDir "nebula.exe"

# ----------------------------------------------------------------------------
# Global State
# ----------------------------------------------------------------------------

$Global:FAILURE_REASON = ""
$Global:NODE_NAME = ""
$Global:REMOTE_VERSION = ""
$Global:OLD_VERSION = ""
$Global:BACKUP_CREATED = $false
$Global:config = @{}

# ----------------------------------------------------------------------------
# Core Functions (Critical - throw on failure)
# ----------------------------------------------------------------------------

function Initialize-Logging {
    $MaxLogSize = 1MB
    if (Test-Path $LogFile) {
        $log = Get-Item $LogFile
        if ($log.Length -gt $MaxLogSize) {
            $oldLog = Join-Path $ScriptDir "update.log.old"
            Rename-Item -Path $LogFile -NewName $oldLog -Force
            Write-Log "INFO: Rotated log file"
        }
    }
}

function Write-Log {
    param([string]$Message, [string]$Level = "I")
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntry = "[$timestamp] [$Level] $Message"
    Add-Content -Path $LogFile -Value $logEntry -ErrorAction SilentlyContinue
    switch ($Level) {
        "OK" { Write-Host $logEntry -ForegroundColor Green }
        "W"  { Write-Host $logEntry -ForegroundColor Yellow }
        "E"  { Write-Host $logEntry -ForegroundColor Red }
        default   { Write-Host $logEntry }
    }
}

function Read-Config {
    if (-not (Test-Path $ConfigFile)) {
        Write-Log "Configuration file not found: $ConfigFile" -Level "E"
        throw "Missing configuration file"
    }

    $config = @{}
    Get-Content $ConfigFile | ForEach-Object {
        if ($_ -match '^\s*([^=]+)\s*=\s*(.+)\s*$') {
            $key = $matches[1].Trim()
            $value = $matches[2].Trim('"'' ')
            $config[$key] = $value
        }
    }

    $required = @("UPDATE_SERVER", "AUTH_USER", "AUTH_PASS", "UPDATE_PASS")
    foreach ($key in $required) {
        if (-not $config.ContainsKey($key) -or [string]::IsNullOrEmpty($config[$key])) {
            Write-Log "Missing required configuration: $key" -Level "E"
            throw "Missing required configuration: $key"
        }
    }

    return $config
}

# ----------------------------------------------------------------------------
# Helper Functions
# ----------------------------------------------------------------------------

function Get-LocalVersion {
    if (Test-Path $LocalVersionFile) {
        return (Get-Content $LocalVersionFile -Raw).Trim()
    } else {
        return "0.0.0"
    }
}

function Get-NodeName {
    if (Test-Path $LocalNodeFile) {
        return (Get-Content $LocalNodeFile -Raw).Trim()
    } else {
        return $null
    }
}

function Get-NebulaVersion {
    if (Test-Path $NebulaBinary) {
        try {
            $output = & $NebulaBinary --version 2>&1
            if ($LASTEXITCODE -eq 0) {
                $match = [regex]::Match($output, 'Version:\s*([0-9\.]+)')
                if ($match.Success) {
                    return $match.Groups[1].Value
                }
            }
        }
        catch {}
    }
    return "unknown"
}

function Decrypt-Package {
    param([string]$InputPath, [string]$OutputPath, [string]$Password)

    try {
        $encryptedBytes = [System.IO.File]::ReadAllBytes($InputPath)
        if ($encryptedBytes.Length -lt 16) {
            Write-Log "File too small for OpenSSL format" -Level "E"
            return $false
        }
        $header = [System.Text.Encoding]::ASCII.GetString($encryptedBytes[0..7])
        if ($header -ne "Salted__") {
            Write-Log "Invalid OpenSSL format (missing Salted__ header)" -Level "E"
            return $false
        }
        $salt = $encryptedBytes[8..15]
        $passwordBytes = [System.Text.Encoding]::UTF8.GetBytes($Password)
        $derived = New-Object System.Security.Cryptography.Rfc2898DeriveBytes(
            $passwordBytes, $salt, 100000, [System.Security.Cryptography.HashAlgorithmName]::SHA256
        )
        $key = $derived.GetBytes(32)
        $iv = $derived.GetBytes(16)
        $aes = [System.Security.Cryptography.Aes]::Create()
        $aes.Key = $key
        $aes.IV = $iv
        $aes.Mode = [System.Security.Cryptography.CipherMode]::CBC
        $aes.Padding = [System.Security.Cryptography.PaddingMode]::PKCS7
        $decryptor = $aes.CreateDecryptor()
        $ciphertext = $encryptedBytes[16..($encryptedBytes.Length - 1)]
        $plaintext = $decryptor.TransformFinalBlock($ciphertext, 0, $ciphertext.Length)
        [System.IO.File]::WriteAllBytes($OutputPath, $plaintext)
        Write-Log "Package decrypted successfully" -Level "I"
        return $true
    }
    catch {
        Write-Log "Decryption failed: $_" -Level "E"
        return $false
    }
}

function Test-NetworkConnectivity {
    param([string]$Server)

    $maxAttempts = 3
    $attempt = 1

    while ($attempt -le $maxAttempts) {
        try {
            $request = [System.Net.WebRequest]::Create($Server)
            $request.Timeout = 5000
            $request.Method = "HEAD"
            $response = $request.GetResponse()
            $response.Close()
            Write-Log "Network connectivity check successful (attempt $attempt/$maxAttempts)" -Level "I"
            return $true
        }
        catch {
            if ($attempt -lt $maxAttempts) {
                Write-Log "Network connectivity check failed (attempt $attempt/$maxAttempts)" -Level "W"
                Start-Sleep -Seconds 2
            }
            $attempt++
        }
    }

    $Global:FAILURE_REASON = "NETWORK_UNREACHABLE"
    Write-Log "Network connectivity check failed after $maxAttempts attempts" -Level "E"
    return $false
}

# ----------------------------------------------------------------------------
# Update Steps
# ----------------------------------------------------------------------------

function Step-CheckRemoteVersion {
    param([string]$Server, [string]$User, [string]$Pass)

    $versionUrl = "$Server/version.txt"
    $maxRetries = 2
    $retryCount = 0

    while ($retryCount -le $maxRetries) {
        try {
            $credential = [System.Convert]::ToBase64String(
                [System.Text.Encoding]::ASCII.GetBytes("${User}:${Pass}")
            )

            $headers = @{ "Authorization" = "Basic $credential" }

            $response = Invoke-WebRequest -Uri $versionUrl -Headers $headers -TimeoutSec 10 -ErrorAction Stop -UseBasicParsing

            if ($response.StatusCode -eq 200) {
                $remoteVersion = $response.Content.Trim()
                
                if ([string]::IsNullOrEmpty($remoteVersion)) {
                    Write-Log "Empty version.txt on server" -Level "I"
                    $Global:REMOTE_VERSION = ""
                    return $true
                }

                $Global:REMOTE_VERSION = $remoteVersion
                Write-Log "Remote version: $remoteVersion" -Level "I"
                return $true
            }
            else {
                $Global:FAILURE_REASON = "SERVER_ERROR_$($response.StatusCode)"
                Write-Log "HTTP error $($response.StatusCode) fetching remote version" -Level "E"
                return $false
            }
        }
        catch [System.Net.WebException] {
            if ($_.Exception.Response -and $_.Exception.Response.StatusCode.value__ -eq 404) {
                $Global:REMOTE_VERSION = ""
                return $true
            }
            elseif ($_.Exception.Response -and 
                    ($_.Exception.Response.StatusCode.value__ -eq 401 -or 
                     $_.Exception.Response.StatusCode.value__ -eq 403)) {
                $Global:FAILURE_REASON = "AUTH_FAILED"
                Write-Log "Authentication failed" -Level "E"
                return $false
            }
            else {
                if ($retryCount -lt $maxRetries) {
                    Write-Log "Connection failed, retrying... (attempt $($retryCount + 1)/$maxRetries)" -Level "W"
                    Start-Sleep -Seconds 3
                    $retryCount++
                    continue
                }
                $Global:FAILURE_REASON = "SERVER_UNREACHABLE"
                Write-Log "Update server unreachable or error: $($_.Exception.Message)" -Level "E"
                return $false
            }
        }
        catch {
            if ($retryCount -lt $maxRetries) {
                Write-Log "Connection failed, retrying... (attempt $($retryCount + 1)/$maxRetries)" -Level "W"
                Start-Sleep -Seconds 3
                $retryCount++
                continue
            }
            $Global:FAILURE_REASON = "SERVER_UNREACHABLE"
            Write-Log "Update server unreachable: $($_.Exception.Message)" -Level "E"
            return $false
        }
    }
    
    $Global:FAILURE_REASON = "SERVER_UNREACHABLE"
    Write-Log "Update server unreachable after $maxRetries retries" -Level "E"
    return $false
}

function Step-ValidateNode {
    $nodeName = Get-NodeName
    if ([string]::IsNullOrEmpty($nodeName)) {
        $Global:FAILURE_REASON = "NODE_NAME_MISSING"
        Write-Log "Node name file missing or empty" -Level "E"

        $configYaml = Join-Path $ScriptDir "config.yaml"
        if (Test-Path $configYaml) {
            $firstLine = Get-Content $configYaml -First 1 -ErrorAction SilentlyContinue
            if ($firstLine -and $firstLine.StartsWith("#")) {
                $Global:FAILURE_REASON = "NODE_NAME_MISSING ($firstLine)"
            }
        }

        return $false
    }

    $Global:NODE_NAME = $nodeName
    return $true
}

function Step-DownloadPackage {
    param([string]$Server, [string]$User, [string]$Pass, [string]$RemoteVersion, [string]$UpdatePass)

    $packageName = "${Global:NODE_NAME}_${RemoteVersion}.zip.enc"
    $packageUrl = "$Server/$packageName"
    Write-Log "Downloading encrypted package: $packageName" -Level "I"

    if (Test-Path $DownloadDir) {
        Remove-Item -Path $DownloadDir -Recurse -Force -ErrorAction SilentlyContinue
    }

    try {
        New-Item -ItemType Directory -Path $DownloadDir -Force | Out-Null

        $credential = [System.Convert]::ToBase64String(
            [System.Text.Encoding]::ASCII.GetBytes("${User}:${Pass}")
        )

        $headers = @{ "Authorization" = "Basic $credential" }
        $encryptedPath = Join-Path $DownloadDir $packageName

        Invoke-WebRequest -Uri $packageUrl -Headers $headers -OutFile $encryptedPath -TimeoutSec 30 -ErrorAction Stop -UseBasicParsing

        $zipPath = $encryptedPath -replace '\.enc$', ''

        if (-not (Decrypt-Package -InputPath $encryptedPath -OutputPath $zipPath -Password $UpdatePass)) {
            Write-Log "Failed to decrypt package" -Level "E"
            return $null
        }

        Remove-Item -Path $encryptedPath -Force -ErrorAction SilentlyContinue
        Expand-Archive -Path $zipPath -DestinationPath $DownloadDir -Force -ErrorAction Stop
        Remove-Item -Path $zipPath -Force -ErrorAction SilentlyContinue

        return $DownloadDir
    }
    catch {
        $Global:FAILURE_REASON = "INVALID_PACKAGE"
        Write-Log "Missing or invalid package on server" -Level "E"
        return $null
    }
}

function Step-ValidateDeploymentPackage {
    param([string]$PackageDir)

    $targetDir = "C:\nebula\@@tun_device@@"

    $deployScript = Join-Path $PackageDir "deploy.ps1"
    if (-not (Test-Path $deployScript)) {
        $Global:FAILURE_REASON = "NO_DEPLOY_SCRIPT"
        Write-Log "deploy.ps1 not found in package" -Level "E"
        return $false
    }

    if (-not (Test-Path (Join-Path $PackageDir "config.yaml"))) {
        $Global:FAILURE_REASON = "MISSING_CONFIG"
        Write-Log "config.yaml not found in package" -Level "E"
        return $false
    }

    $packageNebula = Test-Path (Join-Path $PackageDir "nebula.exe")
    $targetNebula = Test-Path (Join-Path $targetDir "nebula.exe")
    if (-not $packageNebula -and -not $targetNebula) {
        $Global:FAILURE_REASON = "MISSING_NEBULA"
        Write-Log "nebula.exe not found in package OR target directory" -Level "E"
        return $false
    }

    $systemArch = Get-SystemArchitecture
    if (-not $systemArch) {
        $Global:FAILURE_REASON = "UNKNOWN_ARCHITECTURE"
        Write-Log "Could not determine system architecture" -Level "E"
        return $false
    }

    $packageWintun = $false
    $targetWintun = $false
    $packageWintunPath = Join-Path $PackageDir "dist\windows\wintun\bin\$systemArch\wintun.dll"
    if (Test-Path $packageWintunPath) {
        $packageWintun = $true
    }
    if (-not $packageWintun) {
        $targetWintunPath = Join-Path $targetDir "dist\windows\wintun\bin\$systemArch\wintun.dll"
        if (Test-Path $targetWintunPath) {
            $targetWintun = $true
        }
    }
    if (-not $packageWintun -and -not $targetWintun) {
        $Global:FAILURE_REASON = "MISSING_WINTUN"
        Write-Log "wintun.dll ($systemArch) not found in package OR target directory" -Level "E"
        return $false
    }

    return $true
}

function Get-SystemArchitecture {
    if (-not [Environment]::Is64BitOperatingSystem) {
        Write-Error "32-bit Windows is not supported by Nebula"
        return $null
    }
    try {
        $envVar = [Environment]::GetEnvironmentVariable("PROCESSOR_ARCHITECTURE", "Machine")
        
        switch ($envVar) {
            "ARM64" { return "arm64" }
            "AMD64" { return "amd64" }
            default {
                Write-Error "Unsupported architecture: $envVar"
                return $null
            }
        }
    }
    catch {
        Write-Warning "Could not detect architecture via environment variable"
        try {
            $cpu = Get-ItemProperty -Path "HKLM:\HARDWARE\DESCRIPTION\System\CentralProcessor\0" -ErrorAction Stop
            if ($cpu.Identifier -match "ARM") {
                return "arm64"
            } else {
                return "amd64"
            }
        }
        catch {
            Write-Error "Failed to detect system architecture"
            return $null
        }
    }
}

function Step-CreateBackup {
    Write-Log "Creating backup" -Level "I"

    if (Test-Path $BackupDir) {
        Remove-Item -Path $BackupDir -Recurse -Force -ErrorAction SilentlyContinue
    }

    try {
        New-Item -ItemType Directory -Path $BackupDir -Force | Out-Null

        if (Test-Path $NebulaBinary) {
            Copy-Item -Path $NebulaBinary -Destination $BackupDir -Force -ErrorAction Stop
        }

        Get-ChildItem -Path $ScriptDir -File | Where-Object {
            $_.Name -notmatch '\.log$|update-status\.json$'
        } | ForEach-Object {
            Copy-Item -Path $_.FullName -Destination $BackupDir -Force -ErrorAction SilentlyContinue
        }

        $Global:BACKUP_CREATED = $true
        return $true
    }
    catch {
        $Global:FAILURE_REASON = "BACKUP_FAILED"
        Write-Log "Failed to create backup" -Level "E"
        return $false
    }
}

function Step-ApplyUpdate {
    param([string]$PackageDir)

    $deployScript = Join-Path $PackageDir "deploy.ps1"

    if (-not (Test-Path $deployScript)) {
        $Global:FAILURE_REASON = "NO_DEPLOY_SCRIPT"
        Write-Log "deploy.ps1 not found in package" -Level "E"
        return $false
    }

    try {
        Write-Log "Running deployment script..." -Level "I"
        $deployOutput = & powershell.exe -ExecutionPolicy Bypass -File "$deployScript" 2>&1

        if ($deployOutput) {
            foreach ($line in $deployOutput) {
                Write-Log "  $line" -Level "I"
            }
        }

        if ($LASTEXITCODE -eq 0) {
            Write-Log "Update applied" -Level "I"
            return $true
        } else {
            $errorPatterns = @{
                "MISSING_NEBULA:" = "MISSING_NEBULA"
                "MISSING_WINTUN:" = "MISSING_WINTUN"
                "WRONG_WINTUN_ARCH:" = "WRONG_WINTUN_ARCH"
                "config.yaml not found" = "MISSING_CONFIG"
            }

            foreach ($line in $deployOutput) {
                foreach ($pattern in $errorPatterns.Keys) {
                    if ($line -like "*$pattern*") {
                        $Global:FAILURE_REASON = $errorPatterns[$pattern]
                        break
                    }
                }
                if ($Global:FAILURE_REASON) { break }
            }

            if (-not $Global:FAILURE_REASON) {
                $Global:FAILURE_REASON = "DEPLOY_FAILED"
            }

            Write-Log "Deployment script failed with exit code: $LASTEXITCODE" -Level "E"
            return $false
        }
    }
    catch {
        $Global:FAILURE_REASON = "DEPLOY_FAILED"
        Write-Log "Failed to run deployment script: $_" -Level "E"
        return $false
    }
}

function Step-VerifyUpdate {
    param([string]$ExpectedVersion)

    if (-not (Test-Path $LocalVersionFile)) {
        $Global:FAILURE_REASON = "VERIFICATION_FAILED"
        Write-Log "Version file not found after update" -Level "E"
        return $false
    }

    Start-Sleep -Seconds 1
    $newLocalVersion = (Get-Content $LocalVersionFile -Raw).Trim()

    if ($newLocalVersion -ne $ExpectedVersion) {
        $Global:FAILURE_REASON = "VERIFICATION_FAILED"
        Write-Log "Version mismatch after update" -Level "E"
        return $false
    }

    Write-Log "Update verified" -Level "I"
    return $true
}

function Step-RestoreBackup {
    if (-not $Global:BACKUP_CREATED) {
        return $true
    }

    Write-Log "Restoring from backup" -Level "W"

    if (-not (Test-Path $BackupDir)) {
        Write-Log "Backup directory not found" -Level "E"
        return $false
    }

    try {
        if (Test-Path $NebulaBinary) {
            Start-Process -FilePath $NebulaBinary -ArgumentList "-service stop" -NoNewWindow -Wait -ErrorAction SilentlyContinue | Out-Null
            Start-Sleep -Seconds 2
        }

        Get-ChildItem -Path $BackupDir -File | ForEach-Object {
            $destination = Join-Path $ScriptDir $_.Name
            Copy-Item -Path $_.FullName -Destination $destination -Force -ErrorAction SilentlyContinue
        }

        Write-Log "Files restored from backup" -Level "I"

        if (Test-Path $NebulaBinary) {
            Start-Process -FilePath $NebulaBinary -ArgumentList "-service start" -NoNewWindow -Wait -ErrorAction SilentlyContinue | Out-Null
        }

        return $true
    }
    catch {
        Write-Log "Failed to restore backup" -Level "E"
        return $false
    }
}

function Step-CheckService {
    try {
        Start-Sleep -Seconds 3
        $service = Get-Service -Name "Nebula" -ErrorAction SilentlyContinue
        if ($service) {
            if ($service.Status -eq "Running") {
                Write-Log "Nebula service is running" -Level "OK"
                return $true
            } else {
                Write-Log "Nebula service exists but is $($service.Status)" -Level "W"
                Write-Log "Service may need manual start or configuration check" -Level "W"
                return $false
            }
        } else {
            Write-Log "Nebula service not found - check installation" -Level "W"
            return $false
        }
    }
    catch {
        Write-Log "Could not check Nebula service status" -Level "W"
        return $false
    }
}

# ----------------------------------------------------------------------------
# Cleanup and Reporting
# ----------------------------------------------------------------------------

function Cleanup-Temp {
    if (Test-Path $BackupDir) {
        Remove-Item -Path $BackupDir -Recurse -Force -ErrorAction SilentlyContinue
    }

    if (Test-Path $DownloadDir) {
        Remove-Item -Path $DownloadDir -Recurse -Force -ErrorAction SilentlyContinue
    }
}

function Report-Result {
    param([int]$ResultCode)

    $nodeName = if ($Global:NODE_NAME) { $Global:NODE_NAME } else { "UNKNOWN" }
    $nebulaVersion = Get-NebulaVersion

    switch ($ResultCode) {
        0 { $resultText = "updated" }
        1 { $resultText = "no_update" }
        2 { $resultText = "error" }
        default { $resultText = "unknown" }
    }

    $status = @{
        node = $nodeName
        result = $resultText
        previous = $Global:OLD_VERSION
        current = $Global:REMOTE_VERSION
        nebula = $nebulaVersion
        failure_reason = $Global:FAILURE_REASON
        timestamp = Get-Date -Format "yyyy-MM-ddTHH:mm:ss"
    }

    try {
        $statusJson = $status | ConvertTo-Json
        Set-Content -Path $StatusFile -Value $statusJson -ErrorAction SilentlyContinue
    }
    catch {
        Write-Log "WARNING: Could not write status file" -Level "W"
    }

    if ($Global:config.ContainsKey("NTFY_CHANNEL") -and -not [string]::IsNullOrEmpty($Global:config.NTFY_CHANNEL)) {
        try {
            $channel = $Global:config.NTFY_CHANNEL.Trim()
            if (-not [string]::IsNullOrEmpty($channel)) {
                $ntfyUrl = "https://ntfy.sh/$channel"
                $title = "$nodeName @ @@tun_device@@"

                switch ($ResultCode) {
                    0 {  # SUCCESS
                        $tags = "white_check_mark"
                        $priority = 3
                        $body = "Updated from $($Global:OLD_VERSION) --> $($Global:REMOTE_VERSION)`nNebula version: $nebulaVersion"
                    }
                    2 {  # ERROR
                        $tags = "warning"
                        $priority = 4
                        if ($Global:REMOTE_VERSION) {
                            $body = "Update to $($Global:REMOTE_VERSION) FAILED"
                        } else {
                            $body = "Update FAILED"
                        }

                        $body += "`nNode: $nodeName"
                        $body += "`nReason: $($Global:FAILURE_REASON)"

                        switch -Wildcard ($Global:FAILURE_REASON) {
                            "*MISSING_NEBULA*" { $body += " (Missing nebula.exe binary)" }
                            "*MISSING_WINTUN*" { $body += " (Missing wintun.dll driver)" }
                            "*WRONG_WINTUN_ARCH*" { $body += " (Wrong architecture wintun.dll)" }
                            "*MISSING_CONFIG*" { $body += " (Missing config.yaml)" }
                            "*NODE_NAME_MISSING*" { $body += " (Missing node name file)" }
                            "*INVALID_PACKAGE*" { $body += " (Missing or invalid package)" }
                        }

                        $body += "`nNebula: $nebulaVersion"
                    }
                }

                if ($body) {
                    Invoke-RestMethod -Uri $ntfyUrl -Method Post -Body $body `
                        -Headers @{ Title = $title; Tags = $tags; Priority = $priority } `
                        -ErrorAction SilentlyContinue | Out-Null
                }
            }
        }
        catch {
            Write-Log "WARNING: Failed to send ntfy.sh notification" -Level "W"
        }
    }
}

# ----------------------------------------------------------------------------
# Main Control Flow
# ----------------------------------------------------------------------------

try {
    # Initialize
    Initialize-Logging
    Write-Log "Nebula Auto-Update for Windows"

    # Core initialization
    $Global:config = Read-Config
    
    # Get node name early for reporting
    $nodeName = Get-NodeName
    if ([string]::IsNullOrEmpty($nodeName)) {
        $Global:NODE_NAME = "UNKNOWN"
    } else {
        $Global:NODE_NAME = $nodeName
    }

    # Check network connectivity before proceeding
    if (-not (Test-NetworkConnectivity -Server $Global:config.UPDATE_SERVER)) {
        Report-Result -ResultCode 2
        Write-Log "Network connectivity check failed" -Level "E"
        exit 2
    }

    $Global:OLD_VERSION = Get-LocalVersion

    # Step 1: Check remote version
    if (-not (Step-CheckRemoteVersion -Server $Global:config.UPDATE_SERVER -User $Global:config.AUTH_USER -Pass $Global:config.AUTH_PASS)) {
        Report-Result -ResultCode 2
        Write-Log "Update failed: $($Global:FAILURE_REASON)" -Level "E"
        exit 2
    }

    # Check if update needed
    if ([string]::IsNullOrEmpty($Global:REMOTE_VERSION)) {
        Write-Log "No update available (no version.txt on server)" -Level "I"
        Report-Result -ResultCode 1
        exit 1
    }

    if ($Global:OLD_VERSION -eq $Global:REMOTE_VERSION) {
        Write-Log "Already at version $($Global:OLD_VERSION)" -Level "I"
        Report-Result -ResultCode 1
        exit 1
    }

    Write-Log "Updating: $($Global:OLD_VERSION) to $($Global:REMOTE_VERSION)" -Level "I"

    # Step 2: Validate node name (update variable)
    if (-not (Step-ValidateNode)) {
        Report-Result -ResultCode 2
        Write-Log "Update failed: $($Global:FAILURE_REASON)" -Level "E"
        exit 2
    }

    # Step 3: Download package
    $packageDir = Step-DownloadPackage -Server $Global:config.UPDATE_SERVER -User $Global:config.AUTH_USER -Pass $Global:config.AUTH_PASS -RemoteVersion $Global:REMOTE_VERSION -UpdatePass $Global:config.UPDATE_PASS
    if (-not $packageDir) {
        Report-Result -ResultCode 2
        Write-Log "Update failed: $($Global:FAILURE_REASON)" -Level "E"
        exit 2
    }

    if (-not (Step-ValidateDeploymentPackage -PackageDir $packageDir)) {
        Report-Result -ResultCode 2
        Write-Log "Update failed: $($Global:FAILURE_REASON)" -Level "E"
        Cleanup-Temp
        exit 2
    }

    # Step 4: Create backup
    if (-not (Step-CreateBackup)) {
        Cleanup-Temp
        Report-Result -ResultCode 2
        Write-Log "Update failed: $($Global:FAILURE_REASON)" -Level "E"
        exit 2
    }

    # Step 5: Apply update
    if (-not (Step-ApplyUpdate -PackageDir $packageDir)) {
        Step-RestoreBackup
        Cleanup-Temp
        Report-Result -ResultCode 2
        Write-Log "Update failed: $($Global:FAILURE_REASON)" -Level "E"
        exit 2
    }

    # Step 6: Verify update
    if (-not (Step-VerifyUpdate -ExpectedVersion $Global:REMOTE_VERSION)) {
        Step-RestoreBackup
        Cleanup-Temp
        Report-Result -ResultCode 2
        Write-Log "Update failed: $($Global:FAILURE_REASON)" -Level "E"
        exit 2
    }

    # Step 7: Check service (warning only)
    $serviceCheck = Step-CheckService
    if (-not $serviceCheck) {
        Write-Log "Service check warning - verify Nebula service manually" -Level "W"
    }

    # Success
    Cleanup-Temp

    Write-Log "Update completed" -Level "OK"
    Report-Result -ResultCode 0
    exit 0
}
catch {
    Write-Log "UPDATE FAILED: $_" -Level "E"

    try {
        Report-Result -ResultCode 2
    }
    catch {}

    exit 2
}