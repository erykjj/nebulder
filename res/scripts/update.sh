#!/bin/bash

# ============================================================================
# Self-update script for Linux - execute with sudo bash
# Generated by nebulder - https://github.com/erykjj/nebulder
# MIT License: Copyright (c) 2026 Eryk J.
# ============================================================================

#!/bin/bash

set -euo pipefail

# ----------------------------------------------------------------------------
# Configuration and Paths
# ----------------------------------------------------------------------------
EXEC_DIR="/usr/lib/nebula/@@tun_device@@"
NEBULA_BINARY="${EXEC_DIR}/nebula"
UPDATE_SCRIPT="${EXEC_DIR}/update.sh"
CONFIG_DIR="/etc/nebula/@@tun_device@@"
CONFIG_FILE="${CONFIG_DIR}/update.conf"
LOCAL_VERSION_FILE="${CONFIG_DIR}/version"
LOCAL_NODE_FILE="${LOCAL_NODE_FILE:-${CONFIG_DIR}/node}"
BACKUP_DIR="/var/backups/@@tun_device@@"
SERVICE_DIR="/etc/systemd/system"
SERVICE_NAME="nebula_@@tun_device@@"

# ----------------------------------------------------------------------------
# Global State
# ----------------------------------------------------------------------------
FAILURE_REASON=""
NODE_NAME=""
OLD_VERSION=""
REMOTE_VERSION=""
TEMP_DIR=""
BACKUP_CREATED=false

# ----------------------------------------------------------------------------
# Core Functions (Critical - exit on failure)
# ----------------------------------------------------------------------------

load_configuration() {
    if [[ ! -f "${CONFIG_FILE}" ]]; then
        echo "ERROR: Configuration file not found: ${CONFIG_FILE}" >&2
        exit 1
    fi
    source "${CONFIG_FILE}"
    if [[ -z "${UPDATE_SERVER:-}" || -z "${AUTH_USER:-}" || -z "${AUTH_PASS:-}" || -z "${UPDATE_PASS:-}" ]]; then
        echo "ERROR: Missing required configuration in ${CONFIG_FILE}" >&2
        exit 1
    fi
    NTFY_CHANNEL="${NTFY_CHANNEL:-}"
}

check_root() {
    if [[ $EUID -ne 0 ]]; then
        echo "ERROR: This script must be run as root" >&2
        exit 2
    fi
}

check_dependencies() {
    local required_commands=("curl" "unzip" "openssl")
    for cmd in "${required_commands[@]}"; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
            echo "ERROR: Missing required dependency: $cmd" >&2
            exit 1
        fi
    done
}

# ----------------------------------------------------------------------------
# Helper Functions (Non-critical - set FAILURE_REASON on error)
# ----------------------------------------------------------------------------

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*"
}

get_local_version() {
    if [[ -f "${LOCAL_VERSION_FILE}" ]]; then
        cat "${LOCAL_VERSION_FILE}" 2>/dev/null | tr -d '[:space:]' || echo "0.0.0"
    else
        echo "0.0.0"
    fi
}

get_node_name() {
    if [[ ! -f "${LOCAL_NODE_FILE}" ]]; then
        return 1
    fi
    local node_content=$(cat "${LOCAL_NODE_FILE}" 2>/dev/null | tr -d '[:space:]')
    if [[ -z "$node_content" ]]; then
        return 1
    fi
    echo "$node_content"
    return 0
}

get_nebula_version() {
    if [[ -f "$NEBULA_BINARY" ]]; then
        "$NEBULA_BINARY" --version 2>/dev/null | grep -o "Version: [0-9.]*" | cut -d' ' -f2 || echo "unknown"
    else
        echo "not_found"
    fi
}

check_connectivity() {
    local max_attempts=3
    local attempt=1
    while [[ $attempt -le $max_attempts ]]; do
        if curl -s -I --connect-timeout 5 --max-time 10 "${UPDATE_SERVER}/" >/dev/null 2>&1; then
            return 0
        fi
        log "Network connectivity check failed (attempt $attempt/$max_attempts)"
        sleep 2
        ((attempt++))
    done
    FAILURE_REASON="NETWORK_UNREACHABLE"
    return 1
}

# ----------------------------------------------------------------------------
# Update Steps (Non-critical - return 1 on error, set FAILURE_REASON)
# ----------------------------------------------------------------------------
step_check_remote_version() {
    local server="$1"
    local curl_output
    local http_code
    local max_retries=2
    local retry_count=0
    while [[ $retry_count -le $max_retries ]]; do
        curl_output=$(curl -s -w "%{http_code}" -u "${AUTH_USER}:${AUTH_PASS}" \
            --connect-timeout 10 \
            --max-time 15 \
            "${server}/version.txt" 2>/dev/null)
        http_code=${curl_output: -3}
        curl_output=${curl_output%???}
        if [[ "$http_code" =~ ^[0-9]{3}$ ]] && [[ "$http_code" != "000" ]]; then
            break
        fi
        if [[ $retry_count -lt $max_retries ]]; then
            log "Retrying connection to update server..."
            sleep 3
        fi
        ((retry_count++))
    done
    if [[ ! "$http_code" =~ ^[0-9]{3}$ ]] || [[ "$http_code" == "000" ]]; then
        FAILURE_REASON="SERVER_UNREACHABLE"
        log "Update server unreachable after $max_retries retries"
        return 1
    fi
    if [[ "$http_code" != "200" ]]; then
        if [[ "$http_code" == "401" ]] || [[ "$http_code" == "403" ]]; then
            FAILURE_REASON="AUTH_FAILED"
            log "Authentication failed"
            return 1
        else
            REMOTE_VERSION=""
            return 0
        fi
    fi
    REMOTE_VERSION=$(echo "$curl_output" | tr -d '[:space:]')
    if [[ -z "${REMOTE_VERSION}" ]]; then
        REMOTE_VERSION=""
        return 0
    fi
    return 0
}

step_validate_node() {
    local node_name
    if ! node_name=$(get_node_name); then
        FAILURE_REASON="NODE_NAME_MISSING"
        log "Node name file missing or empty"
        local config_yaml="${CONFIG_DIR}/config.yaml"
        if [[ -f "$config_yaml" ]]; then
            local first_line=$(head -n 1 "$config_yaml" 2>/dev/null || echo "")
            if [[ "$first_line" == \#* ]]; then
                FAILURE_REASON="${FAILURE_REASON} (${first_line})"
            fi
        fi
        return 1
    fi
    NODE_NAME="$node_name"
    return 0
}

step_download_package() {
    local remote_version="$1"
    local package_name="${NODE_NAME}_${remote_version}.zip.enc"
    local package_url="${UPDATE_SERVER}/${package_name}"
    TEMP_DIR=$(mktemp -d -t nebula-update-XXXXXX)
    log "Downloading encrypted package"
    if ! curl -s -u "${AUTH_USER}:${AUTH_PASS}" --connect-timeout 30 -o "${TEMP_DIR}/package.enc" "${package_url}"; then
        FAILURE_REASON="DOWNLOAD_FAILED"
        log "Package download failed"
        return 1
    fi
    log "Decrypting package"
    if ! step_decrypt_package "${TEMP_DIR}/package.enc" "${TEMP_DIR}/package.zip"; then
        FAILURE_REASON="DECRYPTION_FAILED"
        log "Package decryption failed"
        return 1
    fi
    rm -f "${TEMP_DIR}/package.enc"
    if ! unzip -q -d "${TEMP_DIR}" "${TEMP_DIR}/package.zip" 2>/dev/null; then
        FAILURE_REASON="INVALID_PACKAGE"
        log "Invalid or missing package"
        return 1
    fi
    rm -f "${TEMP_DIR}/package.zip"
    return 0
}

step_decrypt_package() {
    local encrypted_file="$1"
    local output_file="$2"
    if [[ ! -f "$encrypted_file" ]] || [[ ! -r "$encrypted_file" ]]; then
        log "ERROR: Encrypted file not found or not readable"
        return 1
    fi
    local file_size=$(stat -c%s "$encrypted_file" 2>/dev/null || stat -f%z "$encrypted_file" 2>/dev/null)
    if [[ $file_size -lt 16 ]]; then
        log "ERROR: Encrypted file too small"
        return 1
    fi
    if openssl enc -aes-256-cbc -d -salt -pbkdf2 -iter 100000 \
        -in "$encrypted_file" \
        -out "$output_file" \
        -pass "pass:${UPDATE_PASS}" 2>/dev/null; then
        log "Package decrypted successfully"
        return 0
    else
        log "ERROR: openssl decryption failed"
        return 1
    fi
}

step_create_backup() {
    rm -rf "${BACKUP_DIR}"
    mkdir -p "${BACKUP_DIR}/config"
    mkdir -p "${BACKUP_DIR}/service"
    mkdir -p "${BACKUP_DIR}/exec"
    for unit in "${SERVICE_NAME}.service" "${SERVICE_NAME}-update.service" "${SERVICE_NAME}-update.timer"; do
        if [[ -f "${SERVICE_DIR}/${unit}" ]]; then
            cp -a "${SERVICE_DIR}/${unit}" "${BACKUP_DIR}/service/" 2>/dev/null || true
        fi
    done
    if [[ -d "${EXEC_DIR}" ]]; then
        cp -a "${EXEC_DIR}"/*.sh "${BACKUP_DIR}/exec/" 2>/dev/null || true
    fi
    if [[ -f "${NEBULA_BINARY}" ]]; then
        cp -a "${NEBULA_BINARY}" "${BACKUP_DIR}/exec/" 2>/dev/null || true
    fi
    if [[ -d "${CONFIG_DIR}" ]]; then
        cp -a "${CONFIG_DIR}/"* "${BACKUP_DIR}/config/" 2>/dev/null || true
    fi
    BACKUP_CREATED=true
    log "Backup created"
    return 0
}

step_apply_update() {
    local temp_dir="$1"
    cd "${temp_dir}" || {
        FAILURE_REASON="CANNOT_CD_TEMP"
        log "Cannot access temp directory"
        return 1
    }
    if [[ ! -f "./deploy.sh" ]]; then
        FAILURE_REASON="NO_DEPLOY_SCRIPT"
        log "Missing deploy.sh in package"
        return 1
    fi
    chmod +x ./deploy.sh
    if ! ./deploy.sh; then
        FAILURE_REASON="DEPLOY_FAILED"
        log "deploy.sh failed"
        return 1
    fi
    log "Update applied"
    return 0
}

step_verify_update() {
    local expected_version="$1"
    local new_local_version
    sync
    sleep 1
    new_local_version=$(get_local_version)
    if [[ "$new_local_version" != "$expected_version" ]]; then
        FAILURE_REASON="VERIFICATION_FAILED"
        log "Version mismatch after update"
        return 1
    fi
    log "Update verified"
    return 0
}

step_restore_backup() {
    if [[ "$BACKUP_CREATED" != true ]]; then
        return 0
    fi
    log "Restoring from backup"
    if [[ ! -d "${BACKUP_DIR}" ]]; then
        log "Backup directory not found"
        return 1
    fi
    systemctl stop "${SERVICE_NAME}.service" 2>/dev/null || true
    sleep 2
    pkill -f "nebula .*${EXEC_DIR}/nebula" 2>/dev/null || true
    sleep 1
    if [[ -d "${BACKUP_DIR}/service" ]]; then
        for unit in "${BACKUP_DIR}/service"/*; do
            if [[ -f "$unit" ]]; then
                cp -a "$unit" "${SERVICE_DIR}"
            fi
        done
        systemctl daemon-reload 2>/dev/null || true
    fi
    if [[ -d "${BACKUP_DIR}/exec" ]]; then
        cp -a "${BACKUP_DIR}/exec"/*.sh "${EXEC_DIR}/" 2>/dev/null || true
    fi
    if [[ -f "${BACKUP_DIR}/exec/nebula" ]]; then
        cp -f "${BACKUP_DIR}/exec/nebula" "${NEBULA_BINARY}" 2>/dev/null || true
        chown nebula:nebula "${NEBULA_BINARY}" 2>/dev/null || true
        chmod 750 "${NEBULA_BINARY}" 2>/dev/null || true
        setcap cap_net_admin=+pe "${NEBULA_BINARY}" 2>/dev/null || true
    fi
    if [[ -d "${BACKUP_DIR}/config" ]]; then
        rm -rf "${CONFIG_DIR}"
        mkdir -p "${CONFIG_DIR}"
        cp -a "${BACKUP_DIR}/config/"* "${CONFIG_DIR}/" 2>/dev/null || true
        chown -R nebula:nebula "${CONFIG_DIR}" 2>/dev/null || true
    fi
    systemctl start "${SERVICE_NAME}.service" 2>/dev/null || true
    log "Backup restored"
    return 0
}

step_check_service() {
    if systemctl is-active --quiet "${SERVICE_NAME}"; then
        log "Service running"
        return 0
    else
        FAILURE_REASON="SERVICE_NOT_RUNNING"
        log "Service not running"
        return 1
    fi
}

# ----------------------------------------------------------------------------
# Cleanup and Reporting
# ----------------------------------------------------------------------------

cleanup_temp() {
    if [[ -n "$TEMP_DIR" ]] && [[ -d "$TEMP_DIR" ]]; then
        rm -rf "$TEMP_DIR"
    fi
}

cleanup_backup() {
    if [[ -d "$BACKUP_DIR" ]]; then
        rm -rf "$BACKUP_DIR"
    fi
}

report_result() {
    local result_code="$1"
    local result_text=""
    local nebula_version=$(get_nebula_version)
    case $result_code in
        0) result_text="success" ;;
        1) result_text="no_update" ;;
        2) result_text="error" ;;
        3) result_text="interrupted" ;;
    esac
    local status_dir="/var/run/nebula/@@tun_device@@"
    mkdir -p "$status_dir"
    cat > "${status_dir}/update-status.json" << EOF
{
"node": "$NODE_NAME",
"result": "$result_text",
"previous": "$OLD_VERSION",
"current": "$REMOTE_VERSION",
"nebula": "$nebula_version",
"failure_reason": "$FAILURE_REASON",
"timestamp": "$(date -Iseconds)"
}
EOF
    chmod 755 "$status_dir" 2>/dev/null || true
    chmod 644 "${status_dir}/update-status.json" 2>/dev/null || true
    if [[ -n "${NTFY_CHANNEL:-}" ]]; then
        local channel_clean=$(echo "${NTFY_CHANNEL}" | tr -d '[:space:]')
        if [[ -n "$channel_clean" ]]; then
            local ntfy_url="https://ntfy.sh/${channel_clean}"
            local message=""
            local tags=""
            local priority=""
            case $result_code in
                0) 
                    message="Updated: ${OLD_VERSION} → ${REMOTE_VERSION}"$'\n'"Nebula: ${nebula_version}"
                    tags="white_check_mark"
                    priority="3"
                    ;;
                1) 
                    ;;
                2) 
                    if [[ -n "$REMOTE_VERSION" ]]; then
                        message="Update to ${REMOTE_VERSION} FAILED"
                    else
                        message="Update FAILED"
                    fi
                    message="${message}"$'\n'"Node: ${NODE_NAME}"$'\n'"Reason: ${FAILURE_REASON}"
                    message="${message}"$'\n'"Nebula: ${nebula_version}"
                    tags="warning"
                    priority="4"
                    ;;
            esac
            if [[ -n "$message" ]]; then
                echo "$message" | \
                    curl -H "Title: ${NODE_NAME} @ @@tun_device@@" \
                         -H "Tags:${tags}" \
                         -H "Priority:${priority}" \
                         --data-binary @- "${ntfy_url}" >/dev/null 2>&1 || true
            fi
        fi
    fi
}

# ----------------------------------------------------------------------------
# Main Control Flow
# ----------------------------------------------------------------------------

handle_interruption() {
    log "Update interrupted"
    FAILURE_REASON="INTERRUPTED"
    if [[ "$BACKUP_CREATED" == true ]]; then
        step_restore_backup
    fi
    cleanup_temp
    cleanup_backup
    report_result 3 "$(get_local_version)" "" "INTERRUPTED"
    exit 3
}

main() {
    trap 'handle_interruption' INT TERM
    check_root
    load_configuration
    check_dependencies
    NODE_NAME=$(get_node_name || echo "UNKNOWN")
    if ! check_connectivity; then
        report_result 2
        log "Network connectivity check failed"
        exit 2
    fi
    OLD_VERSION=$(get_local_version)

    # Step 1: Check remote version
    if ! step_check_remote_version "$UPDATE_SERVER"; then
        report_result 2
        log "Update failed: $FAILURE_REASON"
        exit 2
    fi

    # Check if we got a remote version
    if [[ -z "$REMOTE_VERSION" ]]; then
        log "No update available (no version.txt on server)"
        report_result 1
        exit 1
    fi

    # Check if update needed
    if [[ "$OLD_VERSION" == "$REMOTE_VERSION" ]]; then
        log "Already at version $OLD_VERSION"
        report_result 1
        exit 1
    fi
    log "Updating: $OLD_VERSION → $REMOTE_VERSION"

    # Step 2: Validate node name
    if ! step_validate_node; then
        report_result 2
        log "Update failed: $FAILURE_REASON"
        exit 2
    fi

    # Step 3: Download package
    if ! step_download_package "$REMOTE_VERSION"; then
        report_result 2
        log "Update failed: $FAILURE_REASON"
        exit 2
    fi

    # Step 4: Create backup
    if ! step_create_backup; then
        cleanup_temp
        report_result 2 "$REMOTE_VERSION" "BACKUP_FAILED"
        log "Update failed: $FAILURE_REASON"
        exit 2
    fi

    # Step 5: Apply update
    if ! step_apply_update "$TEMP_DIR"; then
        step_restore_backup
        cleanup_temp
        cleanup_backup
        report_result 2 "$REMOTE_VERSION" "$FAILURE_REASON"
        log "Update failed: $FAILURE_REASON"
        exit 2
    fi

    # Step 6: Verify update
    if ! step_verify_update "$REMOTE_VERSION"; then
        step_restore_backup
        cleanup_temp
        cleanup_backup
        report_result 2 "$REMOTE_VERSION" "$FAILURE_REASON"
        log "Update failed: $FAILURE_REASON"
        exit 2
    fi

    # Step 7: Check service (warning only)
    step_check_service || true

    # Success
    cleanup_temp
    cleanup_backup
    log "Update completed"
    report_result 0 "$REMOTE_VERSION" ""
    exit 0
}

main "$@"