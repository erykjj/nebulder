#!/bin/bash

# ============================================================================
# Self-update script for macOS - execute with sudo bash
# Generated by nebulder - https://github.com/erykjj/nebulder
# MIT License: Copyright (c) 2026 Eryk J.
# ============================================================================

set -euo pipefail

# ----------------------------------------------------------------------------
# Configuration and Paths (macOS-specific)
# ----------------------------------------------------------------------------
EXEC_DIR="/usr/local/lib/nebula/@@tun_device@@"
NEBULA_BINARY="${EXEC_DIR}/nebula"
UPDATE_SCRIPT="${EXEC_DIR}/update.sh"
CONFIG_DIR="/usr/local/etc/nebula/@@tun_device@@"
LOCAL_VERSION_FILE="${CONFIG_DIR}/version"
LOCAL_NODE_FILE="${CONFIG_DIR}/node"
BACKUP_DIR="/var/backups/@@tun_device@@"
SERVICE_NAME="nebula_@@tun_device@@"

# ----------------------------------------------------------------------------
# Global State
# ----------------------------------------------------------------------------
FAILURE_REASON=""
NODE_NAME=""
REMOTE_VERSION=""
TEMP_DIR=""
BACKUP_CREATED=false
OLD_VERSION=""

# ----------------------------------------------------------------------------
# Core Functions (Critical - exit on failure)
# ----------------------------------------------------------------------------

load_configuration() {
    CONFIG_FILE="${CONFIG_DIR}/update.conf"
    if [[ ! -f "${CONFIG_FILE}" ]]; then
        echo "ERROR: Configuration file not found: ${CONFIG_FILE}" >&2
        exit 1
    fi

    source "${CONFIG_FILE}"

    if [[ -z "${UPDATE_SERVER:-}" || -z "${AUTH_USER:-}" || -z "${AUTH_PASS:-}" ]]; then
        echo "ERROR: Missing required configuration in ${CONFIG_FILE}" >&2
        exit 1
    fi

    NTFY_CHANNEL="${NTFY_CHANNEL:-}"
}

check_root() {
    if [[ $EUID -ne 0 ]]; then
        echo "ERROR: This script must be run as root" >&2
        exit 2
    fi
}

check_dependencies() {
    if ! command -v curl >/dev/null 2>&1; then
        echo "ERROR: Missing required dependency: curl" >&2
        exit 1
    fi

    if ! command -v unzip >/dev/null 2>&1; then
        echo "ERROR: Missing required dependency: unzip" >&2
        exit 1
    fi
}

# ----------------------------------------------------------------------------
# Helper Functions
# ----------------------------------------------------------------------------

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*"
}

get_local_version() {
    if [[ -f "${LOCAL_VERSION_FILE}" ]]; then
        cat "${LOCAL_VERSION_FILE}" 2>/dev/null | tr -d '[:space:]' || echo "0.0.0"
    else
        echo "0.0.0"
    fi
}

get_node_name() {
    if [[ ! -f "${LOCAL_NODE_FILE}" ]]; then
        return 1
    fi

    local node_content=$(cat "${LOCAL_NODE_FILE}" 2>/dev/null | tr -d '[:space:]')
    if [[ -z "$node_content" ]]; then
        return 1
    fi

    echo "$node_content"
    return 0
}

get_nebula_version() {
    if [[ -f "$NEBULA_BINARY" ]]; then
        "$NEBULA_BINARY" --version 2>/dev/null | grep -o "Version: [0-9.]*" | cut -d' ' -f2 || echo "unknown"
    else
        echo "not_found"
    fi
}

trim_log() {
    local log_file="$1"
    local max_size_mb=1
    local max_size_bytes=$((max_size_mb * 1024 * 1024))
    if [[ -f "$log_file" ]] && [[ $(stat -f%z "$log_file" 2>/dev/null || echo 0) -gt $max_size_bytes ]]; then
        tail -c ${max_size_bytes} "$log_file" > "${log_file}.tmp" && mv "${log_file}.tmp" "$log_file"
    fi
}

# ----------------------------------------------------------------------------
# Update Steps
# ----------------------------------------------------------------------------

step_check_remote_version() {
    local server="$1"
    local curl_output
    local http_code

    curl_output=$(curl -s -w "%{http_code}" -u "${AUTH_USER}:${AUTH_PASS}" --max-time 10 "${server}/version.txt" 2>/dev/null)
    http_code=${curl_output: -3}
    curl_output=${curl_output%???}

    if [[ "$http_code" != "200" ]]; then
        if [[ "$http_code" == "000" ]] || [[ -z "$http_code" ]]; then
            FAILURE_REASON="SERVER_UNREACHABLE"
            log "Update server unreachable"
            return 1
        elif [[ "$http_code" == "401" ]] || [[ "$http_code" == "403" ]]; then
            FAILURE_REASON="AUTH_FAILED"
            log "Authentication failed"
            return 1
        else
            REMOTE_VERSION=""
            return 0
        fi
    fi

    REMOTE_VERSION=$(echo "$curl_output" | tr -d '[:space:]')
    if [[ -z "${REMOTE_VERSION}" ]]; then
        REMOTE_VERSION=""
        return 0
    fi

    return 0
}

step_validate_node() {
    if ! NODE_NAME=$(get_node_name); then
        FAILURE_REASON="NODE_NAME_MISSING"

        log "Node name file missing or empty"

        local config_yaml="${CONFIG_DIR}/config.yaml"
        if [[ -f "$config_yaml" ]]; then
            local first_line=$(head -n 1 "$config_yaml" 2>/dev/null || echo "")
            if [[ "$first_line" == \#* ]]; then
                log "Config hint: $first_line"
                FAILURE_REASON="${FAILURE_REASON} (${first_line})"
            fi
        fi

        return 1
    fi
    return 0
}

step_download_package() {
    local remote_version="$1"
    local package_name="${NODE_NAME}_${remote_version}.zip"
    local package_url="${UPDATE_SERVER}/${package_name}"

    TEMP_DIR=$(mktemp -d -t nebula-update-XXXXXX)

    log "Downloading package"
    if ! curl -s -u "${AUTH_USER}:${AUTH_PASS}" --connect-timeout 30 -o "${TEMP_DIR}/package.zip" "${package_url}"; then
        FAILURE_REASON="DOWNLOAD_FAILED"
        log "Package download failed"
        return 1
    fi

    if ! unzip -q -d "${TEMP_DIR}" "${TEMP_DIR}/package.zip" 2>/dev/null; then
        FAILURE_REASON="INVALID_PACKAGE"
        log "Invalid or missing package"
        return 1
    fi

    return 0
}

step_create_backup() {
    rm -rf "${BACKUP_DIR}"
    mkdir -p "${BACKUP_DIR}/config"
    mkdir -p "${BACKUP_DIR}/launchd"
    mkdir -p "${BACKUP_DIR}/exec"

    for plist in "${SERVICE_NAME}.plist" "${SERVICE_NAME}-update.plist"; do
        if [[ -f "/Library/LaunchDaemons/${plist}" ]]; then
            cp -a "/Library/LaunchDaemons/${plist}" "${BACKUP_DIR}/launchd/" 2>/dev/null || true
        fi
    done

    if [[ -d "${EXEC_DIR}" ]]; then
        cp -a "${EXEC_DIR}"/*.sh "${BACKUP_DIR}/exec/" 2>/dev/null || true
    fi

    if [[ -f "${NEBULA_BINARY}" ]]; then
        cp -a "${NEBULA_BINARY}" "${BACKUP_DIR}/exec/" 2>/dev/null || true
    fi

    if [[ -d "${CONFIG_DIR}" ]]; then
        cp -a "${CONFIG_DIR}/"* "${BACKUP_DIR}/config/" 2>/dev/null || true
    fi

    BACKUP_CREATED=true
    log "Backup created"
    return 0
}

step_apply_update() {
    local temp_dir="$1"

    cd "${temp_dir}" || {
        FAILURE_REASON="CANNOT_CD_TEMP"
        log "Cannot access temp directory"
        return 1
    }

    if [[ ! -f "./deploy.sh" ]]; then
        FAILURE_REASON="NO_DEPLOY_SCRIPT"
        log "Missing deploy.sh in package"
        return 1
    fi

    chmod +x ./deploy.sh
    log "Running deploy.sh..."

    if ! ./deploy.sh; then
        FAILURE_REASON="DEPLOY_FAILED"
        log "deploy.sh failed"
        return 1
    fi

    log "Update applied"
    return 0
}

step_verify_update() {
    local expected_version="$1"
    local new_local_version

    sync
    sleep 1

    new_local_version=$(get_local_version)

    if [[ "$new_local_version" != "$expected_version" ]]; then
        FAILURE_REASON="VERIFICATION_FAILED"
        log "Version mismatch after update"
        return 1
    fi

    log "Update verified"
    return 0
}

step_restore_backup() {
    if [[ "$BACKUP_CREATED" != true ]]; then
        return 0
    fi

    log "Restoring from backup"

    if [[ ! -d "${BACKUP_DIR}" ]]; then
        log "Backup directory not found"
        return 1
    fi

    sudo launchctl bootout system "/Library/LaunchDaemons/${SERVICE_NAME}.plist" 2>/dev/null || true
    sleep 2

    if [[ -d "${BACKUP_DIR}/exec" ]]; then
        cp -a "${BACKUP_DIR}/exec"/*.sh "${EXEC_DIR}/" 2>/dev/null || true
    fi

    if [[ -f "${BACKUP_DIR}/exec/nebula" ]]; then
        cp -a "${BACKUP_DIR}/exec/nebula" "${NEBULA_BINARY}"
    fi

    if [[ -d "${BACKUP_DIR}/config" ]]; then
        rm -rf "${CONFIG_DIR}"
        mkdir -p "${CONFIG_DIR}"
        cp -a "${BACKUP_DIR}/config/"* "${CONFIG_DIR}/" 2>/dev/null || true
    fi

    if [[ -d "${BACKUP_DIR}/launchd" ]]; then
        for plist in "${BACKUP_DIR}/launchd"/*.plist; do
            if [[ -f "$plist" ]]; then
                cp -a "$plist" "/Library/LaunchDaemons/"
            fi
        done
    fi

    log "Reloading service..."
    sudo launchctl bootstrap system "/Library/LaunchDaemons/${SERVICE_NAME}.plist" 2>/dev/null || true

    log "Backup restored"
    return 0
}

step_check_service() {
    if launchctl print "system/${SERVICE_NAME}" >/dev/null 2>&1; then
        log "Service loaded"
        return 0
    else
        FAILURE_REASON="SERVICE_NOT_LOADED"
        log "Service not loaded in launchd"
        return 1
    fi
}

step_trim_logs() {
    trim_log "/usr/local/var/log/nebula_@@tun_device@@.log"
    trim_log "/usr/local/var/log/nebula_@@tun_device@@-update.log"
    log "Logs trimmed"
    return 0
}

# ----------------------------------------------------------------------------
# Cleanup and Reporting
# ----------------------------------------------------------------------------

cleanup_temp() {
    if [[ -n "$TEMP_DIR" ]] && [[ -d "$TEMP_DIR" ]]; then
        rm -rf "$TEMP_DIR"
    fi
}

cleanup_backup() {
    if [[ -d "$BACKUP_DIR" ]]; then
        rm -rf "$BACKUP_DIR"
    fi
}

report_result() {
    local result_code="$1"
    local result_text=""
    local node_name="${NODE_NAME:-UNKNOWN}"
    local nebula_version=$(get_nebula_version)

    case $result_code in
        0) result_text="success" ;;
        1) result_text="no_update" ;;
        2) result_text="error" ;;
        3) result_text="interrupted" ;;
    esac

    local status_dir="/var/run/nebula/@@tun_device@@"
    mkdir -p "$status_dir"
    cat > "${status_dir}/update-status.json" << EOF
{
"node": "$node_name",
"result": "$result_text",
"previous": "$OLD_VERSION",
"current": "$REMOTE_VERSION",
"nebula": "$nebula_version",
"failure_reason": "$FAILURE_REASON",
"timestamp": "$(date -Iseconds)"
}
EOF

    chmod 755 "$status_dir" 2>/dev/null || true
    chmod 644 "${status_dir}/update-status.json" 2>/dev/null || true

    if [[ -n "${NTFY_CHANNEL:-}" ]]; then
        local channel_clean=$(echo "${NTFY_CHANNEL}" | tr -d '[:space:]')
        if [[ -n "$channel_clean" ]]; then
            local ntfy_url="https://ntfy.sh/${channel_clean}"
            local message=""
            local tags=""
            local priority=""

            case $result_code in
                0) 
                    message="Updated: ${OLD_VERSION} → ${REMOTE_VERSION}"$'\n'"Nebula: ${nebula_version}"
                    tags="white_check_mark"
                    priority="3"
                    ;;
                2) 
                    if [[ -n "$REMOTE_VERSION" ]]; then
                        message="Update to ${REMOTE_VERSION} FAILED"
                    else
                        message="Update FAILED"
                    fi

                    message="${message}"$'\n'"Reason: ${FAILURE_REASON}"
                    message="${message}"$'\n'"Nebula: ${nebula_version}"
                    tags="warning"
                    priority="4"
                    ;;
            esac

            if [[ -n "$message" ]]; then
                echo "$message" | \
                    curl -H "Title: ${node_name} @ @@tun_device@@" \
                         -H "Tags:${tags}" \
                         -H "Priority:${priority}" \
                         --data-binary @- "${ntfy_url}" >/dev/null 2>&1 || true
            fi
        fi
    fi
}

# ----------------------------------------------------------------------------
# Main Control Flow
# ----------------------------------------------------------------------------

handle_interruption() {
    log "Update interrupted"
    FAILURE_REASON="INTERRUPTED"

    if [[ "$BACKUP_CREATED" == true ]]; then
        step_restore_backup
    fi

    cleanup_temp
    cleanup_backup

    report_result 3
    exit 3
}

main() {
    trap 'handle_interruption' INT TERM

    # Critical initialization (exit on failure)
    check_root
    load_configuration
    check_dependencies

    OLD_VERSION=$(get_local_version)

    # Step 1: Check remote version
    if ! step_check_remote_version "$UPDATE_SERVER"; then
        report_result 2
        log "Update failed: $FAILURE_REASON"
        exit 2
    fi

    # Check if we got a remote version
    if [[ -z "$REMOTE_VERSION" ]]; then
        log "No update available (no version.txt on server)"
        report_result 1  # no_update
        exit 1
    fi

    # Check if update needed
    if [[ "$OLD_VERSION" == "$REMOTE_VERSION" ]]; then
        log "Already at version $OLD_VERSION"
        report_result 1  # no_update
        exit 1
    fi

    log "Updating: $OLD_VERSION → $REMOTE_VERSION"

    # Step 2: Validate node name
    if ! step_validate_node; then
        report_result 2
        log "Update failed: $FAILURE_REASON"
        exit 2
    fi

    # Step 3: Download package
    if ! step_download_package "$REMOTE_VERSION"; then
        report_result 2
        log "Update failed: $FAILURE_REASON"
        exit 2
    fi

    # Step 4: Create backup
    if ! step_create_backup; then
        cleanup_temp
        report_result 2
        log "Update failed: BACKUP_FAILED"
        exit 2
    fi

    # Step 5: Apply update
    if ! step_apply_update "$TEMP_DIR"; then
        step_restore_backup
        cleanup_temp
        cleanup_backup
        report_result 2
        log "Update failed: $FAILURE_REASON"
        exit 2
    fi

    # Step 6: Verify update
    if ! step_verify_update "$REMOTE_VERSION"; then
        step_restore_backup
        cleanup_temp
        cleanup_backup
        report_result 2
        log "Update failed: $FAILURE_REASON"
        exit 2
    fi

    # Step 7: Check service (warning only)
    step_check_service || true

    # Step 8: Trim logs
    step_trim_logs

    # Success
    cleanup_temp
    cleanup_backup

    log "Update completed"
    report_result 0
    exit 0
}

main "$@"