#!/bin/bash

# ============================================================================
# Self-update script for macOS - execute with sudo bash
# Generated by nebulder - https://github.com/erykjj/nebulder
# MIT License: Copyright (c) 2026 Eryk J.
# ============================================================================

set -euo pipefail

# ----------------------------------------------------------------------------
# Configuration and Paths (macOS-specific)
# ----------------------------------------------------------------------------
EXEC_DIR="/usr/local/lib/nebula/@@tun_device@@"
NEBULA_BINARY="${EXEC_DIR}/nebula"
UPDATE_SCRIPT="${EXEC_DIR}/update.sh"
CONFIG_DIR="/usr/local/etc/nebula/@@tun_device@@"
LOCAL_VERSION_FILE="${CONFIG_DIR}/version"
LOCAL_NODE_FILE="${CONFIG_DIR}/node"
BACKUP_DIR="/var/backups/@@tun_device@@"
SERVICE_NAME="nebula_@@tun_device@@"

# ----------------------------------------------------------------------------
# Global State
# ----------------------------------------------------------------------------
FAILURE_REASON=""
NODE_NAME=""
REMOTE_VERSION=""
TEMP_DIR=""
BACKUP_CREATED=false
OLD_VERSION=""

# ----------------------------------------------------------------------------
# Core Functions (Critical - exit on failure)
# ----------------------------------------------------------------------------

load_configuration() {
    CONFIG_FILE="${CONFIG_DIR}/update.conf"
    if [[ ! -f "${CONFIG_FILE}" ]]; then
        echo "ERROR: Configuration file not found: ${CONFIG_FILE}" >&2
        exit 1
    fi

    source "${CONFIG_FILE}"

    if [[ -z "${UPDATE_SERVER:-}" || -z "${AUTH_USER:-}" || -z "${AUTH_PASS:-}" || -z "${UPDATE_PASS:-}" ]]; then
        echo "ERROR: Missing required configuration in ${CONFIG_FILE}" >&2
        exit 1
    fi

    NTFY_CHANNEL="${NTFY_CHANNEL:-}"
}

check_root() {
    if [[ $EUID -ne 0 ]]; then
        echo "ERROR: This script must be run as root" >&2
        exit 2
    fi
}

check_dependencies() {
    local required_commands=("curl" "unzip" "openssl")
    for cmd in "${required_commands[@]}"; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
            echo "ERROR: Missing required dependency: $cmd" >&2
            exit 1
        fi
    done
}

# ----------------------------------------------------------------------------
# Helper Functions
# ----------------------------------------------------------------------------

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*"
}

get_local_version() {
    if [[ -f "${LOCAL_VERSION_FILE}" ]]; then
        cat "${LOCAL_VERSION_FILE}" 2>/dev/null | tr -d '[:space:]' || echo "0.0.0"
    else
        echo "0.0.0"
    fi
}

get_node_name() {
    if [[ ! -f "${LOCAL_NODE_FILE}" ]]; then
        return 1
    fi

    local node_content=$(cat "${LOCAL_NODE_FILE}" 2>/dev/null | tr -d '[:space:]')
    if [[ -z "$node_content" ]]; then
        return 1
    fi

    echo "$node_content"
    return 0
}

get_nebula_version() {
    if [[ -f "$NEBULA_BINARY" ]]; then
        "$NEBULA_BINARY" --version 2>/dev/null | grep -o "Version: [0-9.]*" | cut -d' ' -f2 || echo "unknown"
    else
        echo "not_found"
    fi
}

trim_log() {
    local log_file="$1"
    local max_size_mb=1
    local max_size_bytes=$((max_size_mb * 1024 * 1024))
    if [[ -f "$log_file" ]] && [[ $(stat -f%z "$log_file" 2>/dev/null || echo 0) -gt $max_size_bytes ]]; then
        tail -c ${max_size_bytes} "$log_file" > "${log_file}.tmp" && mv "${log_file}.tmp" "$log_file"
    fi
}

check_connectivity() {
    local max_attempts=3
    local attempt=1

    while [[ $attempt -le $max_attempts ]]; do
        if curl -s -I --connect-timeout 5 --max-time 10 "${UPDATE_SERVER}/" >/dev/null 2>&1; then
            return 0
        fi

        log "Network connectivity check failed (attempt $attempt/$max_attempts)"
        sleep 2
        ((attempt++))
    done

    FAILURE_REASON="NETWORK_UNREACHABLE"
    return 1
}

# ----------------------------------------------------------------------------
# Update Steps
# ----------------------------------------------------------------------------

step_check_remote_version() {
    local server="$1"
    local curl_output
    local http_code
    local max_retries=2
    local retry_count=0

    while [[ $retry_count -le $max_retries ]]; do
        curl_output=$(curl -s -w "%{http_code}" -u "${AUTH_USER}:${AUTH_PASS}" \
            --connect-timeout 10 \
            --max-time 15 \
            "${server}/version.txt" 2>/dev/null)

        http_code=${curl_output: -3}
        curl_output=${curl_output%???}

        if [[ "$http_code" =~ ^[0-9]{3}$ ]] && [[ "$http_code" != "000" ]]; then
            break
        fi

        if [[ $retry_count -lt $max_retries ]]; then
            log "Retrying connection to update server..."
            sleep 3
        fi
        ((retry_count++))
    done

    if [[ ! "$http_code" =~ ^[0-9]{3}$ ]] || [[ "$http_code" == "000" ]]; then
        FAILURE_REASON="SERVER_UNREACHABLE"
        log "Update server unreachable after $max_retries retries"
        return 1
    fi

    if [[ "$http_code" != "200" ]]; then
        if [[ "$http_code" == "401" ]] || [[ "$http_code" == "403" ]]; then
            FAILURE_REASON="AUTH_FAILED"
            log "Authentication failed"
            return 1
        else
            REMOTE_VERSION=""
            return 0
        fi
    fi

    REMOTE_VERSION=$(echo "$curl_output" | tr -d '[:space:]')
    if [[ -z "${REMOTE_VERSION}" ]]; then
        REMOTE_VERSION=""
        return 0
    fi

    return 0
}

step_validate_node() {
    local node_name
    if ! node_name=$(get_node_name); then
        FAILURE_REASON="NODE_NAME_MISSING"

        log "Node name file missing or empty"

        local config_yaml="${CONFIG_DIR}/config.yaml"
        if [[ -f "$config_yaml" ]]; then
            local first_line=$(head -n 1 "$config_yaml" 2>/dev/null || echo "")
            if [[ "$first_line" == \#* ]]; then
                log "Config hint: $first_line"
                FAILURE_REASON="${FAILURE_REASON} (${first_line})"
            fi
        fi

        return 1
    fi
    NODE_NAME="$node_name"
    return 0
}

step_download_package() {
    local remote_version="$1"
    local package_name="${NODE_NAME}_${remote_version}.zip.enc"
    local package_url="${UPDATE_SERVER}/${package_name}"

    TEMP_DIR=$(mktemp -d -t nebula-update-XXXXXX)

    log "Downloading encrypted package"
    if ! curl -s -u "${AUTH_USER}:${AUTH_PASS}" --connect-timeout 30 -o "${TEMP_DIR}/package.enc" "${package_url}"; then
        FAILURE_REASON="DOWNLOAD_FAILED"
        log "Package download failed"
        return 1
    fi

    log "Decrypting package"
    if ! step_decrypt_package "${TEMP_DIR}/package.enc" "${TEMP_DIR}/package.zip"; then
        FAILURE_REASON="DECRYPTION_FAILED"
        log "Package decryption failed"
        return 1
    fi
    rm -f "${TEMP_DIR}/package.enc"

    if ! unzip -q -d "${TEMP_DIR}" "${TEMP_DIR}/package.zip" 2>/dev/null; then
        FAILURE_REASON="INVALID_PACKAGE"
        log "Invalid or missing package"
        return 1
    fi
    rm -f "${TEMP_DIR}/package.zip"

    return 0
}

step_decrypt_package() {
    local encrypted_file="$1"
    local output_file="$2"

    if [[ ! -f "$encrypted_file" ]] || [[ ! -r "$encrypted_file" ]]; then
        log "ERROR: Encrypted file not found or not readable"
        return 1
    fi

    local file_size=$(stat -f%z "$encrypted_file" 2>/dev/null)
    if [[ $file_size -lt 16 ]]; then
        log "ERROR: Encrypted file too small"
        return 1
    fi

    if openssl enc -aes-256-cbc -d -salt -pbkdf2 -iter 100000 \
        -in "$encrypted_file" \
        -out "$output_file" \
        -pass "pass:${UPDATE_PASS}" 2>/dev/null; then
        log "Package decrypted successfully"
        return 0
    else
        log "ERROR: openssl decryption failed"
        return 1
    fi
}

step_create_backup() {
    rm -rf "${BACKUP_DIR}"
    mkdir -p "${BACKUP_DIR}/config"
    mkdir -p "${BACKUP_DIR}/launchd"
    mkdir -p "${BACKUP_DIR}/exec"

    for plist in "${SERVICE_NAME}.plist" "${SERVICE_NAME}-update.plist"; do
        if [[ -f "/Library/LaunchDaemons/${plist}" ]]; then
            cp -a "/Library/LaunchDaemons/${plist}" "${BACKUP_DIR}/launchd/" 2>/dev/null || true
        fi
    done

    if [[ -d "${EXEC_DIR}" ]]; then
        cp -a "${EXEC_DIR}"/*.sh "${BACKUP_DIR}/exec/" 2>/dev/null || true
    fi

    if [[ -f "${NEBULA_BINARY}" ]]; then
        cp -a "${NEBULA_BINARY}" "${BACKUP_DIR}/exec/" 2>/dev/null || true
    fi

    if [[ -d "${CONFIG_DIR}" ]]; then
        cp -a "${CONFIG_DIR}/"* "${BACKUP_DIR}/config/" 2>/dev/null || true
    fi

    BACKUP_CREATED=true
    log "Backup created"
    return 0
}

step_apply_update() {
    local temp_dir="$1"

    cd "${temp_dir}" || {
        FAILURE_REASON="CANNOT_CD_TEMP"
        log "Cannot access temp directory"
        return 1
    }

    if [[ ! -f "./deploy.sh" ]]; then
        FAILURE_REASON="NO_DEPLOY_SCRIPT"
        log "Missing deploy.sh in package"
        return 1
    fi

    chmod +x ./deploy.sh
    log "Running deploy.sh..."

    if ! ./deploy.sh; then
        FAILURE_REASON="DEPLOY_FAILED"
        log "deploy.sh failed"
        return 1
    fi

    log "Update applied"
    return 0
}

step_verify_update() {
    local expected_version="$1"
    local new_local_version

    sync
    sleep 1

    new_local_version=$(get_local_version)

    if [[ "$new_local_version" != "$expected_version" ]]; then
        FAILURE_REASON="VERIFICATION_FAILED"
        log "Version mismatch after update"
        return 1
    fi

    log "Update verified"
    return 0
}

step_restore_backup() {
    if [[ "$BACKUP_CREATED" != true ]]; then
        return 0
    fi

    log "Restoring from backup"

    if [[ ! -d "${BACKUP_DIR}" ]]; then
        log "Backup directory not found"
        return 1
    fi

    sudo launchctl bootout system "/Library/LaunchDaemons/${SERVICE_NAME}.plist" 2>/dev/null || true
    sleep 2

    if [[ -d "${BACKUP_DIR}/exec" ]]; then
        cp -a "${BACKUP_DIR}/exec"/*.sh "${EXEC_DIR}/" 2>/dev/null || true
    fi

    if [[ -f "${BACKUP_DIR}/exec/nebula" ]]; then
        cp -a "${BACKUP_DIR}/exec/nebula" "${NEBULA_BINARY}"
    fi

    if [[ -d "${BACKUP_DIR}/config" ]]; then
        rm -rf "${CONFIG_DIR}"
        mkdir -p "${CONFIG_DIR}"
        cp -a "${BACKUP_DIR}/config/"* "${CONFIG_DIR}/" 2>/dev/null || true
    fi

    if [[ -d "${BACKUP_DIR}/launchd" ]]; then
        for plist in "${BACKUP_DIR}/launchd"/*.plist; do
            if [[ -f "$plist" ]]; then
                cp -a "$plist" "/Library/LaunchDaemons/"
            fi
        done
    fi

    log "Reloading service..."
    sudo launchctl bootstrap system "/Library/LaunchDaemons/${SERVICE_NAME}.plist" 2>/dev/null || true

    log "Backup restored"
    return 0
}

step_check_service() {
    if launchctl print "system/${SERVICE_NAME}" >/dev/null 2>&1; then
        log "Service loaded"
        return 0
    else
        FAILURE_REASON="SERVICE_NOT_LOADED"
        log "Service not loaded in launchd"
        return 1
    fi
}

step_trim_logs() {
    trim_log "/usr/local/var/log/nebula_@@tun_device@@.log"
    trim_log "/usr/local/var/log/nebula_@@tun_device@@-update.log"
    log "Logs trimmed"
    return 0
}

# ----------------------------------------------------------------------------
# Cleanup and Reporting
# ----------------------------------------------------------------------------

cleanup_temp() {
    if [[ -n "$TEMP_DIR" ]] && [[ -d "$TEMP_DIR" ]]; then
        rm -rf "$TEMP_DIR"
    fi
}

cleanup_backup() {
    if [[ -d "$BACKUP_DIR" ]]; then
        rm -rf "$BACKUP_DIR"
    fi
}

report_result() {
    local result_code="$1"
    local result_text=""
    local nebula_version=$(get_nebula_version)

    case $result_code in
        0) result_text="success" ;;
        1) result_text="no_update" ;;
        2) result_text="error" ;;
        3) result_text="interrupted" ;;
    esac

    local status_dir="/var/run/nebula/@@tun_device@@"
    mkdir -p "$status_dir"
    cat > "${status_dir}/update-status.json" << EOF
{
"node": "$NODE_NAME",
"result": "$result_text",
"previous": "$OLD_VERSION",
"current": "$REMOTE_VERSION",
"nebula": "$nebula_version",
"failure_reason": "$FAILURE_REASON",
"timestamp": "$(date -Iseconds)"
}
EOF

    chmod 755 "$status_dir" 2>/dev/null || true
    chmod 644 "${status_dir}/update-status.json" 2>/dev/null || true

    if [[ -n "${NTFY_CHANNEL:-}" ]]; then
        local channel_clean=$(echo "${NTFY_CHANNEL}" | tr -d '[:space:]')
        if [[ -n "$channel_clean" ]]; then
            local ntfy_url="https://ntfy.sh/${channel_clean}"
            local message=""
            local tags=""
            local priority=""

            case $result_code in
                0) 
                    message="Updated: ${OLD_VERSION} → ${REMOTE_VERSION}"$'\n'"Nebula: ${nebula_version}"
                    tags="white_check_mark"
                    priority="3"
                    ;;
                2) 
                    if [[ -n "$REMOTE_VERSION" ]]; then
                        message="Update to ${REMOTE_VERSION} FAILED"
                    else
                        message="Update FAILED"
                    fi

                    message="${message}"$'\n'"Node: ${NODE_NAME}"$'\n'"Reason: ${FAILURE_REASON}"
                    message="${message}"$'\n'"Nebula: ${nebula_version}"
                    tags="warning"
                    priority="4"
                    ;;
            esac

            if [[ -n "$message" ]]; then
                echo "$message" | \
                    curl -H "Title: ${NODE_NAME} @ @@tun_device@@" \
                         -H "Tags:${tags}" \
                         -H "Priority:${priority}" \
                         --data-binary @- "${ntfy_url}" >/dev/null 2>&1 || true
            fi
        fi
    fi
}

# ----------------------------------------------------------------------------
# Main Control Flow
# ----------------------------------------------------------------------------

handle_interruption() {
    log "Update interrupted"
    FAILURE_REASON="INTERRUPTED"

    if [[ "$BACKUP_CREATED" == true ]]; then
        step_restore_backup
    fi

    cleanup_temp
    cleanup_backup

    report_result 3
    exit 3
}

main() {
    trap 'handle_interruption' INT TERM

    # Critical initialization (exit on failure)
    check_root
    load_configuration
    check_dependencies

    # Get node name early for reporting
    NODE_NAME=$(get_node_name || echo "UNKNOWN")

    # Check network connectivity before proceeding
    if ! check_connectivity; then
        report_result 2
        log "Network connectivity check failed"
        exit 2
    fi

    OLD_VERSION=$(get_local_version)

    # Step 1: Check remote version
    if ! step_check_remote_version "$UPDATE_SERVER"; then
        report_result 2
        log "Update failed: $FAILURE_REASON"
        exit 2
    fi

    # Check if we got a remote version
    if [[ -z "$REMOTE_VERSION" ]]; then
        log "No update available (no version.txt on server)"
        report_result 1  # no_update
        exit 1
    fi

    # Check if update needed
    if [[ "$OLD_VERSION" == "$REMOTE_VERSION" ]]; then
        log "Already at version $OLD_VERSION"
        report_result 1  # no_update
        exit 1
    fi

    log "Updating: $OLD_VERSION → $REMOTE_VERSION"

    # Step 2: Validate node name
    if ! step_validate_node; then
        report_result 2
        log "Update failed: $FAILURE_REASON"
        exit 2
    fi

    # Step 3: Download package
    if ! step_download_package "$REMOTE_VERSION"; then
        report_result 2
        log "Update failed: $FAILURE_REASON"
        exit 2
    fi

    # Step 4: Create backup
    if ! step_create_backup; then
        cleanup_temp
        report_result 2
        log "Update failed: BACKUP_FAILED"
        exit 2
    fi

    # Step 5: Apply update
    if ! step_apply_update "$TEMP_DIR"; then
        step_restore_backup
        cleanup_temp
        cleanup_backup
        report_result 2
        log "Update failed: $FAILURE_REASON"
        exit 2
    fi

    # Step 6: Verify update
    if ! step_verify_update "$REMOTE_VERSION"; then
        step_restore_backup
        cleanup_temp
        cleanup_backup
        report_result 2
        log "Update failed: $FAILURE_REASON"
        exit 2
    fi

    # Step 7: Check service (warning only)
    step_check_service || true

    # Step 8: Trim logs
    step_trim_logs

    # Success
    cleanup_temp
    cleanup_backup

    log "Update completed"
    report_result 0
    exit 0
}

main "$@"